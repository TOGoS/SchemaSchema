At a low level, the syntax can be described like this:

	word = single-quoted-string | double-quoted-string | bareword
	
	phrase = word { word }
	
	argument-list = parameterized { "," parameterized }
	
	parameterized-subject = phrase
	
	parameterized = parameterized-subject [ "(" argument-list ")" ]
	
	command-block = "=" command | "{" block "}"
	
	modifier-list = { ":" parameterized }
	
	command-subject = parameterized
	
	command = command-subject modifier-list command-block
	
	command-delimiter = ";" | "\n"
	
	block = command { command-delimiter command }

Class definitions are then built on top of commands.  A class definition
is indicated by a command where the subject's phrase starts with the word 'class'.
That command's modifiers indicate things about the class itself, and sub-commands
in that command's block define instance fields.  e.g.

	class patient hospitalization : self-keyed {
		patient ID : integer
		patient admission date : date
	}

Foreign keys
	
	class patient {
		ID : integer : primary key component
		first name : string
		last name : string
	}
	
	class patient stay {
		# Define a foreign key:
		patient : reference(patient) {
			# foreign key = our key.
			# we could also define our key outside the reference block
			# and then not repeat the modifiers, here
			ID = patient ID : integer : primary key component
		}
		patient admission date : date : primary key component
		reason for admission : string
	}
	
	class patient incident {
		patient stay : reference(patient stay) # since key names match, no need to repeat ourselves
	}
